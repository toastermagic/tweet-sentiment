<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="..\..\bower_components/polymer/polymer.html">
<link rel="import" href="..\..\bower_components/paper-checkbox/paper-checkbox.html">

<dom-module id="tweet-toolbar">
  <template>
    <style>
      :host {
        display: block;
      }
      
      paper-checkbox {
        --paper-checkbox-checked-color: #ccc;
        --paper-checkbox-unchecked-color: #ccc;
        --paper-checkbox-label-color: #ccc;
      }
      
      paper-input {
        --paper-input-container-color: #ccc;
        --paper-input-container-focus-color: #fff;
        --paper-input-container-input-color: #ccc;
      }
      
      paper-fab {
        margin-left: 5px;
      }
      
      .count-box {
        border: 3px solid #ccc;
        border-radius: 5px;
        padding: 5px;
      }
    </style>

    <paper-input label="Tracking" on-keydown="checkForEnter" value="{{trackingTerm}}"></paper-input>

    <paper-fab id="shuffle" mini title="shuffle" raised icon="tweet-icons:shuffle" on-tap="shuffle"></paper-fab>
    <paper-fab id="add" mini title="get old tweet" raised icon="tweet-icons:add" on-tap="add"></paper-fab>
    <paper-fab id="refresh" mini title="refresh counts" icon="tweet-icons:refresh" on-tap="refresh"></paper-fab>

    <span class="layout horizontal">
      <paper-button id="unclassifiedCount" raised title="unclassified" class="count-box">
        <iron-icon icon="tweet-icons:unknown"></iron-icon>
        <span>{{counts.unclassified}}</span>
    </paper-button>
    <paper-button id="positiveCount" raised title="positive" class="count-box">
      <iron-icon icon="tweet-icons:thumb-up"></iron-icon>
      <span>{{counts.positive}}</span>
    </paper-button>
    <paper-button id="neutralCount" raised title="neutral" class="count-box">
      <iron-icon icon="tweet-icons:thumbs-up-down"></iron-icon>
      <span>{{counts.neutral}}</span>
    </paper-button>
    <paper-button id="angryCount" raised title="angry" class="count-box">
      <iron-icon icon="tweet-icons:thumb-down"></iron-icon>
      <span>{{counts.angry}}</span>
    </paper-button>
    <paper-button id="irrelevantCount" raised title="irrelevant" class="count-box">
      <iron-icon icon="tweet-icons:delete"></iron-icon>
      <span>{{counts.irrelevant}}</span>
    </paper-button>
    </span>

    <paper-button raised disabled$="{{training}}" style="background:#0c0; margin-right:16px" on-tap="train">Train</paper-button>

    <span>
      <label for="subscribeMode" style="color:#ccc">Subscribe</label>
      <paper-checkbox id="subscribeMode" checked="{{subscribeMode}}"></paper-checkbox>
    <span>
    <span>
      <label for="predictMode" style="color:#ccc">Predict</label>
      <paper-checkbox id="predictMode" checked="{{predictMode}}"></paper-checkbox>
    <span>

  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'tweet-toolbar',

      behaviors: [Polymer.NeonAnimationRunnerBehavior],

      properties: {
        predictMode: {
          type: Boolean,
          value: false ,
          observer: '_changePredict'
        },
        subscribeMode: {
          type: Boolean,
          value: false,
          observer: '_changeSubscribe'
        },
        tweetStream: Object,
        tweetSubscription: Object,
        countSubscription: Object,
        trackingSubscription: Object,
        counts: {
          type: Object,
          notify: true,
          value: {
            angry: '', neutral: '', positive: '', irrelevant: '', unclassified: '' 
          }
        },
        prevCounts: {
          type: Object,
          value: {
            angry: '', neutral: '', positive: '', irrelevant: '', unclassified: '' 
          }
        },
        training: Boolean,
        trackingTerm: {
          type: String,
          notify: true
        },
        animationConfig: {
          value: function() {
            return {
              name: 'ripple-animation',
              node: this
            }
          }
        }                
      },
      checkForEnter: function(e) {
        if (e.keyCode === 13 && this.trackingTerm.length > 2) {
          app.$.toast.text = "Requesting new tracking term:" + this.trackingTerm;
          app.$.toast.show();
          tweetSocket.sendCommand("setTrack", this.trackingTerm);
        }
      },
      _changePredict: function(newPredictMode) {
        app.$.toast.text = "Setting server to " + (newPredictMode ? "predict" : "learn") + "mode";
        app.$.toast.show();
        tweetSocket.sendCommand("apiMode", newPredictMode ? "predict" : "learn");
      },
      _changeSubscribe: function(newSubscribed) {
          if (newSubscribed) {
            app.$.toast.text = "Starting tweet subscription";
            app.$.toast.show();
            this.tweetStream.resume();
          } else {
            if (this.tweetStream) {
              app.$.toast.text = "Pausing tweet subscription";
              app.$.toast.show();
              this.tweetStream.pause();
            }
          }
      },
      rippleElement: function(el) {
        el.getRipple().downAction();
        setTimeout(() => {
          el.getRipple().upAction();
        }, 50);
      },
      updateCount: function(countName, newCounts) {
        if (this.counts[countName] !== newCounts[countName]) {
          this.rippleElement(this.$$("#" + countName + "Count"))
        }
      },
      updateCounts: function(newCounts) {
        _(["angry", "irrelevant", "unclassified", "positive", "neutral"])
        .each((classification) => {
          this.updateCount(classification, newCounts);
        })
        this.counts = newCounts;
      },
      ready: function() {
        this.tweetStream = tweetSocket.tweetStream();

        this.trackingSubscription = tweetSocket.trackingStream.subscribe((term) => {
          this.trackingTerm = term;
          app.$.toast.text = "Now tracking term:" + this.trackingTerm;
          app.$.toast.show();
        });

        this.countSubscription = tweetSocket.countStream.subscribe((newCounts) => {
          this.updateCounts(newCounts);
        });

        this.statusSubscription = tweetSocket.statusStream.subscribe((status) => {
          console.log('training status', status);
          this.training = status.training;
          this.statusMessage = status.message;
          app.$.toast.text = this.statusMessage;
          app.$.toast.show();
        });

        this.subscribeMode = true;
        this.refresh();
        this.getTrack();
      },
      refresh: function() {
        tweetSocket.sendCommand("counts");
      },
      train: function() {
        tweetSocket.sendCommand("train");
      },
      getTrack: function() {
        tweetSocket.sendCommand("getTrack", (term) => {
          this.trackingTerm = term;
        });
      },
      setTrack: function(term) {
        tweetSocket.sendCommand("setTrack", term);
      },
      shuffle: function() {
        this.fire('shuffle');
      },
      add: function() {
        this.fire('add');
      }
    });
  })();
  </script>
</dom-module>